// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title KoinKeren Token
 * @author ByteBreaker
 * @notice ERC-20 token with capped supply, burnable tokens, and controlled minting.
 */
contract KoinKeren is ERC20, ERC20Burnable, Ownable {

    /// @dev Maximum total supply (immutable = gas efficient)
    uint256 public immutable MAX_SUPPLY;

    /// @dev Flag to permanently disable minting
    bool public mintingFinished;

    /// @dev Emitted when new tokens are minted
    event TokensMinted(address indexed to, uint256 amount);

    /// @dev Emitted when minting is permanently disabled
    event MintingFinished();

    /**
     * @param initialSupply Initial supply (WITHOUT decimals)
     * @param maxSupply Maximum supply (WITHOUT decimals)
     */
    constructor(
        uint256 initialSupply,
        uint256 maxSupply
    )
        ERC20("KoinKeren", "KKRN")
        Ownable(msg.sender)
    {
        require(maxSupply > 0, "Max supply must be greater than zero");
        require(initialSupply <= maxSupply, "Initial exceeds max supply");

        MAX_SUPPLY = maxSupply * 10 ** decimals();

        _mint(msg.sender, initialSupply * 10 ** decimals());
    }

    /**
     * @dev Mint new tokens (only owner, only before minting finished)
     */
    function mint(address to, uint256 amount) external onlyOwner {
        require(!mintingFinished, "Minting is finished");
        require(totalSupply() + amount <= MAX_SUPPLY, "Max supply exceeded");

        _mint(to, amount);
        emit TokensMinted(to, amount);
    }

    /**
     * @dev Permanently disable minting
     * @notice Cannot be reversed
     */
    function finishMinting() external onlyOwner {
        require(!mintingFinished, "Minting already finished");

        mintingFinished = true;
        emit MintingFinished();
    }
}
